# 设计模式之美



## 封装、抽象、继承、多态分别解决了哪些编程问题？

1. 封装（encapsulation）

   封装也叫做信息隐藏或者数据访问保护。类通过暴露有限的属性和访问接口，限制外部所能访问的内部信息和操作信息的权限。如类中的private、public等关键字。

   如果我们对类中的属性不加以限制，任何代码都可以访问、修改类中的属性，虽然这样更加灵活，却使得代码变得不可控，任何修改都可能导致该类出现异常。

2. 抽象（abstraction）

   抽象指的是如何隐藏方法的具体实现，让调用者只关心类提供了哪些功能，并不需要知道这些功能如何实现的。

3. 继承（inheritance）

   继承最大的好处就是代码复用。但是，过度使用继承，会导致代码可读性和维护性变差，为了了解一个类所提供的功能，需要按照继承关系一层一层往上查看其父类，如果是多继承则更加复杂。另外，如果子类和父类有耦合代码，修改父类代码会直接影响到子类。因此很多人觉得继承应该少用，甚至不用。

4. 多态（polymorphism）

   多态应用在继承关系中可以理解为子类重写父类的方法。应用在非继承关系则为不同的类都实现了同一套接口。

   多态特性可以提高代码的可扩展性和复用性。



## 面向对象与面向过程

### 面向对象

- 面向对象编程是一种编程范式或编程风格。它以类和对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。数据一般以属性的方式实现在类当中。

- 面向对象编程语言是指具有与支持以上面向对象编程的语法机制的编程语言。


### 面向过程

- 面向过程编程也是一种编程范式或编程风格。它以过程（方法、函数、操作）作为组织代码的基本单元。以数据（成员变量、属性）与方法相分离为最主要的特点。
- 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

### 两者主要区别

面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。

### 面向对象编程的优势

- 对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
- 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。



## 抽象类和接口

### 抽象类

抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。

### 接口

接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

### 抽象类和接口存在的意义

抽象类是对成员变量和方法的抽象，是为了解决代码复用问题。

接口是对实现的抽象，表示其具有某一组行为特性，解耦接口定义和具体的实现，提高代码的扩展性。

### 接口如何设计

我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

### 是否需要为每个类都定义接口？

这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。

从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。



## 为什么不推荐使用继承

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。



## 单一职责原则（SPR）

一个类或者模块只负责完成一个职责（或者功能）。

下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
- 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
- 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

 

####  类的职责是否设计得越单一越好？

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

