# 数据结构与算法之美

## 跳跃表

如果想在链表中使用二分查找算法，只需要对链表添加索引层即可实现，这种数据结构就是跳跃表。

跳跃表的查找、插入、删除时间复杂度为`O(logn)`。相比一般的链表，时间复杂度为O(n)，提升不少。

跳跃表会增加一定的空间复杂度，但是依然为`O(n)`。

跳跃表的实现难点在于`索引动态更新`，作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

## 散列表

把元素的键值，通过计算一一转化成可寻址下标的方法叫做`散列函数`。散列函数计算得出的下标值即`散列值`。`散列表`正是通过散列函数把元素的键值映射为下标。



### 为什么散列表和链表经常会一起使用？

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。

结合散列表和链表，我们可以把LRU缓存淘汰算法的时间复杂度降低到O(1)。



## 二叉树

**节点的高度**：节点到也只节点的最长路径（边数）

**节点的深度**：根节点到这个节点所经历的边数

**节点的层数**：节点的深度 + 1

**树的高度**：根节点的高度

**满二叉树**：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。

**完全二叉树**：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。



### 二叉树的遍历

* 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
* 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
* 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。



### 二叉查找树

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。





## 红黑树

二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。要解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树。

**平衡二叉树**：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。只要树的高度不比log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。



## 借助树来求解递归算法的时间复杂度



